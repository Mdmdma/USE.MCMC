dimensions <- c("PC1", "PC2")
env.data.raster <- USE.MCMC::Worldclim_tmp %>%
terra::rast(type="xyz") %>%
round(2)
rpc <- rastPCA(env.data.raster,  stand = TRUE)
env.data.raster.with.pc <- c(env.data.raster, rpc$PCs)
env.data.sf <- env.data.raster %>%
as.data.frame(xy = TRUE) %>%
sf::st_as_sf(coords = c("x", "y"))
# Attaching the data in the PCA coordinates
env.with.pc.sf <- rpc$PCs %>%
as.data.frame(xy = TRUE) %>%
na.omit() %>%
sf::st_as_sf(coords = c("x", "y")) %>%
sf::st_join(env.data.sf)
env.data.cleaned <- sf::st_drop_geometry(env.with.pc.sf[dimensions])
p.points.in.the.environment <- ggplot() +
geom_point(data=env.data.cleaned,
aes(x=PC1, y=PC2),
color = "black",
size=0.2) +
labs(title = "Points of the environmeltal dataset",
)
p.points.in.the.environment
env.with.pc.sf.subsampled <- env.with.pc.sf[
stats::runif(min(nrow(env.with.pc.sf), 2000) , 1, nrow(env.with.pc.sf)),]
env.data.cleaned.subsampled <- sf::st_drop_geometry(
env.with.pc.sf.subsampled[dimensions])
environmental.data.model <- mclust::densityMclust(env.data.cleaned.subsampled)
title("Gaussian mixture fitted to the environment")
environmental.densities <- mclust::predict.densityMclust(
environmental.data.model, env.data.cleaned)
environmental.threshold <- stats::quantile(environmental.densities, 0.01)
densityFunctionNaive <- function(env.model, env.threshold, dimensions){
densityFunction <- function(point){
point <- as.data.frame(point)
point <- sf::st_drop_geometry(point[dimensions]) %>%
as.matrix()
env.density <- mclust::predict.densityMclust(env.model, point)
if (env.density < env.threshold){
return(0)
} else {
return(1)
}
}
}
densityFunction <- densityFunctionNaive(environmental.data.model,
environmental.threshold,
dimensions)
gridsize <- 100
grid <- expand.grid(
x = seq(min(env.data.cleaned$PC1), max(env.data.cleaned$PC1), length.out = gridsize),
y = seq(min(env.data.cleaned$PC2), max(env.data.cleaned$PC2), length.out = gridsize)
)
names(grid) <- c("PC1", "PC2")
grid$density <- purrr::map_dbl(1:nrow(grid), ~ densityFunction(grid[.x, , drop = FALSE]))
p.density.naive <- ggplot() +
geom_tile(data=grid, aes(x=PC1, y=PC2, fill=density)) +
geom_point(data=env.data.cleaned, aes(x=PC1, y=PC2), size = 0.1) +
theme_minimal() +
labs(title = "Density function in the naive case")
print(p.density.naive)
sampled.points.naive.density <- mcmcSampling(dataset = env.with.pc.sf,
dimensions = dimensions,
densityFunction = densityFunction,
n.sample.points = 5000,
burnIn = FALSE)
virtual.presence.data <- getVirtualSpeciesPresencePoints(
env.data = env.data.raster.with.pc, n.samples = 300)
virtual.presence.points <- virtual.presence.data$sample.points
virtual.presence.points.pc <- terra::extract(env.data.raster.with.pc,
virtual.presence.points,
bind = TRUE) %>%
sf::st_as_sf()
species.model = mclust::densityMclust(sf::st_drop_geometry(virtual.presence.points.pc[dimensions]))
species.densities <- species.model$density
species.cutoff.threshold <- stats::quantile(species.densities, 0.9)
title("Gaussian mixture model fitted to the target species")
densityFunctionPseudoAbsences <- function(env.model, env.threshold,
pres.model, pres.threshold,
dimensions){
densityFunction <- function(point){
point <- sf::st_drop_geometry(point[dimensions]) %>%
as.matrix()
env.density <- mclust::predict.densityMclust(env.model, point)
if (env.density < env.threshold){
return(0)
} else {
return(
max(0, 1-mclust::predict.densityMclust(pres.model, point) / pres.threshold)
)
}
}
}
densityFunction <- densityFunctionPseudoAbsences(environmental.data.model,
environmental.threshold,
species.model,
species.cutoff.threshold,
dimensions)
grid$density <- purrr::map_dbl(1:nrow(grid), ~ densityFunction(grid[.x, , drop = FALSE]))
p.density.pseudo.absence <- ggplot() +
geom_tile(data=grid, aes(x=PC1, y=PC2, fill=density)) +
geom_point(data=virtual.presence.points.pc, aes(x=PC1, y=PC2, color="Presence"), size = 0.1) +
scale_color_manual(values = c("Presence" = "red"),
name = "Point type") +
theme_minimal() +
labs(title = "Value of the pseudo absence function")
p.density.pseudo.absence
sampled.points.ps.density <- mcmcSampling(dataset = env.with.pc.sf,
dimensions = dimensions,
densityFunction = densityFunction,
n.sample.points = 5000,
burnIn = TRUE)
sampled.points <- sampled.points.ps.density
mapped.sampled.point.locations <- FNN::get.knnx(
env.data.cleaned[dimensions], sampled.points[dimensions],k = 1)
mapped.sampled.points <- env.with.pc.sf[
mapped.sampled.point.locations$nn.index,]
mapped.sampled.points$density <- sampled.points$density
mapped.sampled.points$distance <- mapped.sampled.point.locations$nn.dist
nearest.neighbors.distance<- FNN::knn.dist(env.data.cleaned[dimensions],
k=3) %>%
as.vector()
sorted.nearest.neighbor.distances <- sort(nearest.neighbors.distance,
decreasing=TRUE)
distance.threshold <- sorted.nearest.neighbor.distances[2] / 2
mapped.sampled.points.filtered <- mapped.sampled.points[
mapped.sampled.points$distance < distance.threshold, ]
n.samples <- 300
mapped.sampled.points.selected <- mapped.sampled.points.filtered[
runif(n.samples, 0, nrow(mapped.sampled.points.filtered)), ]
p.points.in.the.environment <- p.density.pseudo.absence +
geom_point(data=mapped.sampled.points.selected,
aes(x=PC1, y=PC2, color="Pseudo-absence"),
,
size=0.2) +
geom_point(data=virtual.presence.points.pc,
aes(x=PC1, y=PC2, color="Presence"),
size=0.2) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black"),
name = "Point type") +
labs(title = "Sampled points in the environmental space")
p.points.in.the.environment
p.mcmc.posterior.pc1 <- ggplot() +
geom_density(data=mapped.sampled.points.selected, aes(x=PC1, color="Pseudo-absence")) +
geom_density(data=env.data.cleaned, aes(x=PC1, color="Environment")) +
geom_density(data=virtual.presence.points.pc, aes(x=PC1, color="Presence")) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black", "Environment" = "green"),
name = "Point type")
p.mcmc.posterior.pc2 <- ggplot() +
geom_density(data=mapped.sampled.points.selected, aes(x=PC2, color="Pseudo-absence")) +
geom_density(data=env.data.cleaned, aes(x=PC2, color="Environment")) +
geom_density(data=virtual.presence.points.pc, aes(x=PC2, color="Presence")) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black", "Environment" = "green"),
name = "Point type")
p.mcmc.posterior.pc3 <- ggplot() +
geom_density(data=mapped.sampled.points.selected, aes(x=PC3, color="Pseudo-absence")) +
geom_density(data=env.with.pc.sf, aes(x=PC3, color="Environment")) +
geom_density(data=virtual.presence.points.pc, aes(x=PC3, color="Presence")) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black", "Environment" = "green"),
name = "Point type")
ggdraw() +
draw_plot(cowplot::plot_grid(p.mcmc.posterior.pc1,
p.mcmc.posterior.pc2,
p.mcmc.posterior.pc3,
ncol = 1),
height = 0.9) +
draw_label("Posterior of compared to Presence and environment",
x = 0.5, y = 0.95, size = 16)
sf::st_crs(mapped.sampled.points.selected) <- 4326
sf::st_crs(virtual.presence.points.pc) <- 4326
sf::st_crs(env.data.sf) <- 4326
p.sampled.points.in.geographical.space <- ggplot() +
geom_sf(data=env.data.sf, aes(color="Environment"), size=0.02, show.legend = FALSE) +
geom_sf(data=mapped.sampled.points.selected, aes(color="Pseudo-absence"), size=1) +
geom_sf(data=virtual.presence.points.pc, aes(color="Presence"), size=1) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black", "Environment" = "lightgreen"),
breaks = c("Presence", "Pseudo-absence"),
name = "Point type") +
theme_minimal() +
labs(title="Sampled points in the geographical space")
p.sampled.points.in.geographical.space
sampled.points.mcmc.higher.dim <- paSamplingMcmc(env.data.raster = env.data.raster,
pres = virtual.presence.points,
precomputed.pca = rpc,
environmental.cutof.percentile = 0.001,
num.chains = 4,
num.cores = 4,
chain.length = 10000,
n.samples = 500,
verbose = TRUE,
dimensions = c("PC1", "PC2", "PC3"))
p.mcmc.posterior.pc1 <- ggplot() +
geom_density(data=sampled.points.mcmc.higher.dim, aes(x=PC1, color="Pseudo-absence")) +
geom_density(data=env.with.pc.sf, aes(x=PC1, color="Environment")) +
geom_density(data=virtual.presence.points.pc, aes(x=PC1, color="Presence")) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black", "Environment" = "green"),
name = "Point type")
p.mcmc.posterior.pc2 <- ggplot() +
geom_density(data=sampled.points.mcmc.higher.dim, aes(x=PC2, color="Pseudo-absence")) +
geom_density(data=env.with.pc.sf, aes(x=PC2, color="Environment")) +
geom_density(data=virtual.presence.points.pc, aes(x=PC2, color="Presence")) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black", "Environment" = "green"),
name = "Point type")
p.mcmc.posterior.pc3 <- ggplot() +
geom_density(data=sampled.points.mcmc.higher.dim, aes(x=PC3, color="Pseudo-absence")) +
geom_density(data=env.with.pc.sf, aes(x=PC3, color="Environment")) +
geom_density(data=virtual.presence.points.pc, aes(x=PC3, color="Presence")) +
scale_color_manual(values = c("Presence" = "red", "Pseudo-absence" = "black", "Environment" = "green"),
name = "Point type")
ggdraw() +
draw_plot(cowplot::plot_grid(p.mcmc.posterior.pc1,
p.mcmc.posterior.pc2,
p.mcmc.posterior.pc3,
ncol = 1),
height = 0.9) +
draw_label("Posterior of compared to Presence and environment",
x = 0.5, y = 0.95, size = 16)
dimensions <- c("PC1", "PC2", "PC3")
# Environmental model in 3 dimensions
env.with.pc.sf.subsampled <- env.with.pc.sf[
stats::runif(min(nrow(env.with.pc.sf), 2000) , 1, nrow(env.with.pc.sf)),] %>%
sf::st_drop_geometry()
env.data.cleaned.subsampled <- sf::st_drop_geometry(
env.with.pc.sf.subsampled[dimensions])
environmental.data.model <- mclust::densityMclust(env.data.cleaned.subsampled)
env.data.cleaned <- sf::st_drop_geometry(env.with.pc.sf[dimensions])
environmental.densities <- mclust::predict.densityMclust(
environmental.data.model, env.data.cleaned)
environmental.threshold <- stats::quantile(environmental.densities, 0.04)
#species model in 3 dimensions
species.model = mclust::densityMclust(sf::st_drop_geometry(virtual.presence.points.pc[dimensions]))
species.densities <- species.model$density
species.cutoff.threshold <- stats::quantile(species.densities, 0.9)
covariance.scaling <-0.075
covariance.matrix <- stats::cov(sf::st_drop_geometry(env.with.pc.sf)[dimensions])
proposalFunction <- addHighDimGaussian(cov.mat =covariance.scaling * covariance.matrix,
dim = length(dimensions))
densityFunction <- mclustDensityFunction(env.model = environmental.data.model,
species.model = species.model,
dim = dimensions,
threshold = environmental.threshold,
species.cutoff.threshold = species.cutoff.threshold)
chain.list <- list()
chain.list <- mclapply(1:4, function(i) {
capture.output({
sampled.points <- mcmcSampling(dataset = env.with.pc.sf.subsampled,
dimensions = dimensions,
n.sample.points = 5000,
densityFunction = densityFunction,
proposalFunction = proposalFunction,
burnIn = TRUE,
verbose = FALSE)
})
chain.list[[i]] <- coda::as.mcmc(sampled.points[dimensions])
}, mc.cores = 4)
coda.chain.list <- coda::mcmc.list(chain.list)
coda::gelman.plot(coda.chain.list)
load_all()
sampled.points.mcmc.higher.dim <- paSamplingMcmc(env.data.raster = env.data.raster,
pres = virtual.presence.points,
precomputed.pca = rpc,
environmental.cutof.percentile = 0.001,
num.chains = 4,
num.cores = 4,
chain.length = 10000,
n.samples = 500,
verbose = TRUE,
dimensions = c("PC1", "PC2", "PC3"))
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#devtools::install_github("mdmdma/USE.MCMC")
library(USE.MCMC)
library(terra)
library(virtualspecies)
library(sf)
library(ggplot2)
library(parallel)
library(FNN)
seed.number = 42
set.seed(seed.number)
env.data.raster <- USE.MCMC::Worldclim_tmp %>%
terra::rast( type="xyz")
env.data.sf <- env.data.raster %>%
as.data.frame(xy = TRUE) %>%
sf::st_as_sf(coords = c("x", "y"))
# Generate the environmental space using PCA
rpc <- rastPCA(env.data.raster,  stand = TRUE)
# Create a raster with the environmental variables as well as pcs
env.data.raster.with.pc <- c(env.data.raster, rpc$PCs)
# Attaching the data in the PCA coordinates
env.with.pc.fs <- rpc$PCs %>%
as.data.frame(xy = TRUE) %>%
na.omit() %>%
sf::st_as_sf(coords = c("x", "y")) %>%
st_join(env.data.sf)
virtual.presence.data <- getVirtualSpeciesPresencePoints(
env.data = env.data.raster.with.pc, n.samples = 300)
virtual.presence.points <- virtual.presence.data$sample.points
virtual.presence.points.pc <- terra::extract(env.data.raster.with.pc,
virtual.presence.points,
bind = TRUE) %>%
sf::st_as_sf()
sampled.points.uniform.p <- paSampling(env.rast = env.data.raster,
pres = virtual.presence.points,
grid.res = 10)
sampled.points.uniform.p.location <- sf::st_drop_geometry(
sampled.points.uniform.p) %>%
dplyr::select(c("x", "y")) %>%
sf::st_as_sf(coords = c("x", "y"))
sampled.points.uniform.paper <- terra::extract(
env.data.raster.with.pc,
sampled.points.uniform.p.location)
n.sample.points = 300
sampled.points.uniform.nn <- paSamplingNn(env.rast = env.data.raster,
pres = virtual.presence.points,
grid.res = 15, n.tr = 2,
n.samples = n.sample.points)
sampled.points.mcmc <- paSamplingMcmc(env.data.raster = env.data.raster,
pres = virtual.presence.points,
precomputed.pca = rpc,
environmental.cutof.percentile = 0.001,
num.chains = 4,
num.cores = 4,
chain.length = 10000,
n.samples = n.sample.points,
verbose = TRUE)
# Create a layout with 3 rows: 2 for plots, 1 for legend
if(TRUE) {
# Create a layout with 3 rows: 2 for plots, 1 for legend
plotting.dimensions <- c("PC1", "PC2", "PC3")
layout(matrix(c(1:(length(plotting.dimensions) + 1)),
nrow = length(plotting.dimensions) + 1,
byrow = TRUE),
heights = c(rep(3, length(plotting.dimensions)) ,1))
par(mar = c(4, 4, 5, 2))  # bottom, left, top, right
plots <- invisible(lapply(plotting.dimensions, function(col) {
x_range <- range(
c(density(env.with.pc.fs[[col]])$x,
density(sampled.points.uniform.nn[[col]])$x,
density(sampled.points.mcmc[[col]])$x)
)
y_range <- range(
c(density(env.with.pc.fs[[col]])$y,
density(sampled.points.uniform.nn[[col]])$y,
density(sampled.points.mcmc[[col]])$y)
)
plot(density(env.with.pc.fs[[col]]),
col = "green",
main = paste("Density Comparison for", col),
xlim = x_range,
ylim = y_range,
lwd = 2)
lines(density(virtual.presence.points.pc[[col]]), col = "black", lwd = 2)
lines(density(sampled.points.uniform.paper[[col]]), col = "orange", lwd = 2)
lines(density(sampled.points.uniform.nn[[col]]), col = "blue", lwd = 2)
lines(density(sampled.points.mcmc[[col]]), col = "red", lwd = 2)
}))
# Create an empty plot for the legend
par(mar = c(0, 0, 0, 0))  # Remove margins
plot.new()
legend("center",
legend = c("Environment", "Virtual Presence", "Sampled Points uniform",
"Sampled Points uniform nn", "Sampled Points mcmc"),
col = c("green", "black", "orange", "blue", "red"),
lwd = 2,
horiz = FALSE,  # Vertical legend (rows)
bty = "n",      # No box around legend
cex = 1.5)      # incease text size
}
sampled.points.mcmc.higher.dim <- paSamplingMcmc(
env.data.raster = env.data.raster,
pres = virtual.presence.points,
precomputed.pca = rpc,
environmental.cutof.percentile = 0.001,
num.chains = 4,
num.cores = 4,
chain.length = 10000,
n.samples = n.sample.points,
verbose = TRUE,
dimensions = c("PC1", "PC2", "PC3"))
# Create a layout with 3 rows: 2 for plots, 1 for legend
if(TRUE) {
# Create a layout with 3 rows: 2 for plots, 1 for legend
plotting.dimensions <- c("PC1", "PC2", "PC3")
layout(matrix(c(1:(length(plotting.dimensions) + 1)),
nrow = length(plotting.dimensions) + 1, byrow = TRUE),
heights = c(rep(2, length(plotting.dimensions)) ,1))
par(mar = c(4, 4, 5, 2))  # bottom, left, top, right
plots <- invisible(lapply(plotting.dimensions, function(col) {
x_range <- range(
c(density(env.with.pc.fs[[col]])$x,
density(sampled.points.uniform.nn[[col]])$x,
density(sampled.points.mcmc.higher.dim[[col]])$x)
)
y_range <- range(
c(density(env.with.pc.fs[[col]])$y,
density(sampled.points.uniform.nn[[col]])$y,
density(sampled.points.mcmc.higher.dim[[col]])$y)
)
plot(density(env.with.pc.fs[[col]]),
col = "green",
main = paste("Density Comparison for", col),
xlim = x_range,
ylim = y_range,
lwd = 2)
lines(density(virtual.presence.points.pc[[col]]), col = "black", lwd = 2)
lines(density(sampled.points.uniform.paper[[col]]), col = "orange", lwd = 2)
lines(density(sampled.points.uniform.nn[[col]]), col = "blue", lwd = 2)
lines(density(sampled.points.mcmc.higher.dim[[col]]), col = "red", lwd = 2)
}))
# Create an empty plot for the legend
par(mar = c(0, 0, 0, 0))  # Remove margins
plot.new()
legend("center",
legend = c("Environment", "Virtual Presence", "Sampled Points uniform",
"Sampled Points uniform nn", "Sampled Points mcmc"),
col = c("green", "black", "orange", "blue", "red"),
lwd = 2,
horiz = FALSE,  # Vertical legend (rows)
bty = "n",      # No box around legend
cex = 1.5)      # incease text size
}
use_package("coda")
use_package("entropy")
‘entropy’ ‘gganimate’ ‘rnaturalearth’
use_package("gg_animate")
use_package("gganimate")
use_package("rnaturalearth")
document
document()
document()
check()
?mcapply
?mclapply
install()
check()
checj
x  <- 3
library(devtools)
install()
check()
build_vignettes()
check())
check()
use_package("rnaturalearth")
check()
install.packages("rnaturalearthdata")
library(devtools)
check()
check()
check()
check()
document()
load_all()
library(devtools)
check(vignettes = FALSE)
}
install()
load_all()
library(USE.MCMC)
library(terra)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(USE.MCMC)
library(terra)
library(terra)
library(USE.MCMC)
library(terra)
library(virtualspecies)
library(sf)
library(ggplot2)
library(parallel)
library(FNN)
library(coda)
library(gganimate)
library(tcltk)
library(viridis)
library(cowplot)
library(entropy)
# fixing the
set.seed(42)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
starting.point <- data.frame(x=0, y=0)
sampled.points <- USE.MCMC::mcmcSampling(dataset=starting.point,
dimensions = c("x", "y"),
densityFunction = alwaysOne,
proposalFunction = addHighDimGaussian(dim=2),
burnIn = 0,
covariance.correction = 1,
n.sample.points = 100,
verbose = FALSE)
test(vignette = FALSE)
library(devtools)
test(vignette = FALSE)
load_all()
test(vignette = false)
library(devtools)
load_all()
check()
check(vignettes = FALSE)
library(devtools)
check(vignettes = FALSE)
library(devtools)
build_site()
