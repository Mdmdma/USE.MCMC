# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 10)
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 10)
load_all()
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 100)
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
load_all()
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 100)
load_all()
virtual.precence.points.pc <- terra::extract(rpc$PCs, virtual.precence.points, bind = TRUE) %>%
sf::st_as_sf()
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 100)
?virtualspecies::sampleOccurrences
check()
?setTxtProgressBar
?points
vcheck()
use_package("mclust")
vcheck
vcheck()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 1000)
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 10000)
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 100)
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 10)
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 1000)
virtual.precence.points.pc <- terra::extract(rpc$PCs, virtual.precence.points, bind = TRUE) %>%
sf::st_as_sf()
virtual.precence.points.pc <- sf::st_drop_geometry(virtual.precence.points.pc[dimensions])
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 10000)
virtual.precence.points.pc <- terra::extract(rpc$PCs, virtual.precence.points, bind = TRUE) %>%
sf::st_as_sf()
virtual.precence.points.pc <- sf::st_drop_geometry(virtual.precence.points.pc[dimensions])
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 100000)
virtual.precence.points.pc <- terra::extract(rpc$PCs, virtual.precence.points, bind = TRUE) %>%
sf::st_as_sf()
virtual.precence.points.pc <- sf::st_drop_geometry(virtual.precence.points.pc[dimensions])
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 1000)
virtual.precence.points.pc <- terra::extract(rpc$PCs, virtual.precence.points, bind = TRUE) %>%
sf::st_as_sf()
virtual.precence.points.pc <- sf::st_drop_geometry(virtual.precence.points.pc[dimensions])
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 100)
virtual.precence.points.pc <- terra::extract(rpc$PCs, virtual.precence.points, bind = TRUE) %>%
sf::st_as_sf()
virtual.precence.points.pc <- sf::st_drop_geometry(virtual.precence.points.pc[dimensions])
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 1000)
View(virtual.precence.points)
# sample species model
virtual.precence.points <- getVirtualSpeciesPresencePoints(environemtalData = envData, n.samples = 1)
virtual.precence.points.pc <- terra::extract(rpc$PCs, virtual.precence.points, bind = TRUE) %>%
sf::st_as_sf()
virtual.precence.points.pc <- sf::st_drop_geometry(virtual.precence.points.pc[dimensions])
species.model = mclust::densityMclust(virtual.precence.points.pc, plot = TRUE)
summary
#density Function
densityFunction <- mclustDensityFunction(environmentalModel = environmental.data.model, presenceModel = species.model,
dim = dimensions, threshold = threshold)
# set sampling parameters
covariance <-0.3
proposalFunction <- addHighDimGaussian(cov_mat =covariance * diag(length(dimensions)), dim = length(dimensions))
# sample points
sampled.points <- mcmcSampling(dataset = envWithPc, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
par(mfrow = c(3, 1))
plot_points_with_lines(sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance),
limits = list(c(min(envWithPc$PC1), max(envWithPc$PC1)), c(min(envWithPc$PC2), max(envWithPc$PC2))))
plot(envWithPc$PC1, envWithPc$PC2, main = paste("Covariance is diagonal ", covariance))
plot(virtual.precence.points.pc$PC1, virtual.precence.points.pc$PC2, xlim = c(min(envWithPc$PC1), max(envWithPc$PC1)),
ylim = c(min(envWithPc$PC2), max(envWithPc$PC2)) )
par(mfrow = c(2, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPc[[col]], main=paste("Histogram of envWithPc", col))))
invisible(lapply(dimensions, function(col) hist(sampled.points[[col]], main=paste("Histogram of envWithPc", col))))
load_all()
plot_points_with_lines(sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance),
limits = list(c(min(envWithPc$PC1), max(envWithPc$PC1)), c(min(envWithPc$PC2), max(envWithPc$PC2))))
plot(envWithPc$PC1, envWithPc$PC2, main = paste("Covariance is diagonal ", covariance))
plot_points_with_lines(sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance),
limits = list(c(min(envWithPc$PC1), max(envWithPc$PC1)), c(min(envWithPc$PC2), max(envWithPc$PC2))))
load_all()
plot(envWithPc$PC1, envWithPc$PC2, main = paste("Covariance is diagonal ", covariance))
plot_points_with_lines(sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance),
limits = list(c(min(envWithPc$PC1), max(envWithPc$PC1)), c(min(envWithPc$PC2), max(envWithPc$PC2))))
par(mfrow = c(3, 1))
plot_points_with_lines(sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance),
limits = list(c(min(envWithPc$PC1), max(envWithPc$PC1)), c(min(envWithPc$PC2), max(envWithPc$PC2))))
mean(v)
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
traceback()
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
use_r()
use_r("plot_density")
#' Calculate Density Values on a Grid
#'
#' @param density_func A function that takes numeric vectors as input and returns density values
#' @param data A dataframe containing the dimensions to use
#' @param dimensions A character vector of column names in the dataframe to use as dimensions
#' @param n_grid Integer specifying the number of grid points in each dimension (default: 100)
#' @param padding Numeric value to extend the grid beyond data limits as percentage (default: 0.05)
#'
#' @return A dataframe with grid points and corresponding density values
#' @export
calculate_density_grid <- function(density_func, data, dimensions, n_grid = 100, padding = 0.05) {
# Check if all dimensions exist in the data
if (!all(dimensions %in% names(data))) {
missing_dims <- dimensions[!dimensions %in% names(data)]
stop("The following dimensions are not found in the data: ",
paste(missing_dims, collapse = ", "))
}
# Check if we're working with 1D, 2D, or higher dimensions
n_dims <- length(dimensions)
if (n_dims < 1) {
stop("At least one dimension must be specified")
}
# Create grid ranges with padding
grid_ranges <- list()
for (dim in dimensions) {
range_values <- range(data[[dim]], na.rm = TRUE)
range_width <- diff(range_values)
padded_min <- range_values[1] - padding * range_width
padded_max <- range_values[2] + padding * range_width
grid_ranges[[dim]] <- seq(padded_min, padded_max, length.out = n_grid)
}
# Create grid coordinates
if (n_dims == 1) {
# 1D case
dim1 <- dimensions[1]
grid_df <- data.frame(grid_ranges[[dim1]])
names(grid_df) <- dim1
# Calculate density at each grid point
grid_df$density <- sapply(grid_df[[dim1]], function(x) {
density_func(x)
})
} else if (n_dims == 2) {
# 2D case
dim1 <- dimensions[1]
dim2 <- dimensions[2]
# Create grid mesh
grid_coords <- expand.grid(
x = grid_ranges[[dim1]],
y = grid_ranges[[dim2]]
)
names(grid_coords) <- dimensions
# Calculate density at each grid point
grid_coords$density <- apply(grid_coords, 1, function(point) {
density_func(point[1], point[2])
})
grid_df <- grid_coords
} else {
# Higher dimensions
# Create the grid as a list of sequences
grid_list <- grid_ranges
# Create all combinations of grid points
grid_coords <- expand.grid(grid_list)
# Calculate density at each grid point
grid_coords$density <- apply(grid_coords, 1, function(point) {
# Need to pass all dimensions to the density function
do.call(density_func, as.list(point))
})
grid_df <- grid_coords
}
return(grid_df)
}
calculate_density_grid(density_func = densityFunction, environmentalData, dimensions = c("PC1","PC2"))
# Extract dimension names
dim_x <- dimensions[1]
source("~/Desktop/semesterarbeit10/USE.MCMC/R/plot_density.R", echo=TRUE)
calculate_density_grid_2d(density_func = densityFunction, environmentalData, dimensions = c("PC1","PC2"))
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
View(presence.points)
View(myPres)
print(presence.points)
View(myPres)
View(myPres)
View(sampled.points)
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
View(environmental.data.model)
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
use_r("mapBackOnRealPoints")
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
real.sampled.point <- sapply(sampled.points, 1, function(point) mapBackOnRealPoints(dataset, point, dimensions))
load_all()
real.sampled.point <- sapply(sampled.points, 1, function(point) mapBackOnRealPoints(dataset, point, dimensions))
real.sampled.point <- apply(sampled.points, 1, function(point) mapBackOnRealPoints(dataset, point, dimensions))
real.sampled.point <- apply(sampled.points, 1, function(point) mapBackOnRealPoints(envDataSf, point, dimensions))
load_all()
real.sampled.point <- apply(sampled.points, 1, function(point) mapBackOnRealPoints(envDataSf, point, dimensions))
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 100,
proposalFunction = proposalFunction, densityFunction = densityFunction)
load_all()
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 100,
proposalFunction = proposalFunction, densityFunction = densityFunction)
par(mfrow = c(3, 1))
plot_points_with_lines(sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance),
limits = list(c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), c(min(envWithPcSf$PC2), max(envWithPcSf$PC2))))
plot_points_with_lines(sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance.proposal.function),
limits = list(c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), c(min(envWithPcSf$PC2), max(envWithPcSf$PC2))))
plot(envWithPcSf$PC1, envWithPcSf$PC2, main = paste("Covariance is diagonal ", covariance.proposal.function))
plot(virtual.precence.points.pc$PC1, virtual.precence.points.pc$PC2, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)),
ylim = c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)) )
par(mfrow = c(2, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) hist(sampled.points[[col]], main=paste("Histogram of sampled points", col))))
sampled.point <- apply(sampled.points, 1, function(point) mapBackOnRealPoints(envDataSf, point, dimensions))
View(sampled.point)
sp <- unlist(sampled.point)
sp
real.sampled.points <- do.call(rbind, sampled.point)
View(real.sampled.points)
library()
library(mathisRhelpers)
gm()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
View(real.sampled.points.list)
real.sampled.points.list <- na.omit(real.sampled.points.list)
View(real.sampled.points.list)
logical[1]
real.sampled.points.list
View(sampled.points)
clean_list <- real.sampled.points.list[!is.na(real.sampled.points.list)]
real.sampled.points <- do.call(rbind, real.sampled.points.list.clean)
real.sampled.points.list.clean <- real.sampled.points.list[!is.na(real.sampled.points.list)]
real.sampled.points <- do.call(rbind, real.sampled.points.list.clean)
#plot
par(mfrow = c(3, 1))
plot_points_with_lines(real.sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance.proposal.function),
limits = list(c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), c(min(envWithPcSf$PC2), max(envWithPcSf$PC2))))
plot(envWithPcSf$PC1, envWithPcSf$PC2, main = paste("Covariance is diagonal ", covariance.proposal.function))
plot(virtual.precence.points.pc$PC1, virtual.precence.points.pc$PC2, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)),
ylim = c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)) )
par(mfrow = c(2, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) hist(real.sampled.points[[col]], main=paste("Histogram of sampled points", col))))
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
# map back onto real points
max.distance <- 2
real.sampled.points.list <- apply(sampled.points, 1, function(point) mapBackOnRealPoints(envWithPcSf, point, dimensions, threshold = max.distance))
cat(sum(is.na(real.sampled.points.list)) ,"points have no real counterpart in the environment space, given a maximal distance of ", max.distance, "!")
real.sampled.points.list.clean <- real.sampled.points.list[!is.na(real.sampled.points.list)]
real.sampled.points <- do.call(rbind, real.sampled.points.list.clean)
#plot
par(mfrow = c(3, 1))
plot_points_with_lines(real.sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance.proposal.function),
limits = list(c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), c(min(envWithPcSf$PC2), max(envWithPcSf$PC2))))
plot(envWithPcSf$PC1, envWithPcSf$PC2, main = paste("Covariance is diagonal ", covariance.proposal.function))
plot(virtual.precence.points.pc$PC1, virtual.precence.points.pc$PC2, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)),
ylim = c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)) )
par(mfrow = c(2, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) hist(real.sampled.points[[col]], main=paste("Histogram of sampled points", col))))
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) hist(virtual.precence.points.pc[[col]], main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) hist(real.sampled.points[[col]], main=paste("Histogram of sampled points", col))))
invisible(lapply(dimensions, function(col) density(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) density(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
data <- rnorm(1000)
plot(density(data), main="Density Plot", xlab="Value")
(lapply(dimensions, function(col) density(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
(lapply(dimensions, function(col) density(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
(lapply(dimensions, function(col) density(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) plot(density(envWithPcSf[[col]]), main=paste("Histogram of environment", col))))
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) plot(density(envWithPcSf[[col]]), main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) plot(density(virtual.precence.points.pc[[col]]), main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) plot(density(real.sampled.points[[col]]), main=paste("Histogram of sampled points", col))))
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
# setup environment to compute in parallel
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
max.distance <- 2
library(parallel)
# setup environment to compute in parallel
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
max.distance <- 2
clusterExport(cl, c("mapBackOnRealPoints", "envWithPcSf", "dimensions", "max.distance"))
# map back onto real points
real.sampled.points.list <- parallel::parApply(cl, sampled.points, 1, function(point) mapBackOnRealPoints(envWithPcSf, point, dimensions, threshold = max.distance))
cat(sum(is.na(real.sampled.points.list)) ,"points have no real counterpart in the environment space, given a maximal distance of ", max.distance, "!")
real.sampled.points.list.clean <- real.sampled.points.list[!is.na(real.sampled.points.list)]
real.sampled.points <- do.call(rbind, real.sampled.points.list.clean)
#plot
par(mfrow = c(3, 1))
plot_points_with_lines(real.sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance.proposal.function),
limits = list(c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), c(min(envWithPcSf$PC2), max(envWithPcSf$PC2))))
plot(envWithPcSf$PC1, envWithPcSf$PC2, main = paste("Covariance is diagonal ", covariance.proposal.function))
plot(virtual.precence.points.pc$PC1, virtual.precence.points.pc$PC2, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)),
ylim = c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)) )
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) hist(virtual.precence.points.pc[[col]], main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) hist(real.sampled.points[[col]], main=paste("Histogram of sampled points", col))))
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) plot(density(envWithPcSf[[col]]), main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) plot(density(virtual.precence.points.pc[[col]]), main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) plot(density(real.sampled.points[[col]]), main=paste("Histogram of sampled points", col))))
# set sampling parameters
covariance.proposal.function <-0.1
proposalFunction <- addHighDimGaussian(cov_mat =covariance.proposal.function * diag(length(dimensions)), dim = length(dimensions))
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
# setup environment to compute in parallel
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
max.distance <- 2
clusterExport(cl, c("mapBackOnRealPoints", "envWithPcSf", "dimensions", "max.distance"))
# map back onto real points
real.sampled.points.list <- parallel::parApply(cl, sampled.points, 1, function(point) mapBackOnRealPoints(envWithPcSf, point, dimensions, threshold = max.distance))
cat(sum(is.na(real.sampled.points.list)) ,"points have no real counterpart in the environment space, given a maximal distance of ", max.distance, "!")
real.sampled.points.list.clean <- real.sampled.points.list[!is.na(real.sampled.points.list)]
real.sampled.points <- do.call(rbind, real.sampled.points.list.clean)
#plot
par(mfrow = c(3, 1))
plot_points_with_lines(real.sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance.proposal.function),
limits = list(c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), c(min(envWithPcSf$PC2), max(envWithPcSf$PC2))))
plot(envWithPcSf$PC1, envWithPcSf$PC2, main = paste("Covariance is diagonal ", covariance.proposal.function))
plot(virtual.precence.points.pc$PC1, virtual.precence.points.pc$PC2, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)),
ylim = c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)) )
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) hist(virtual.precence.points.pc[[col]], main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) hist(real.sampled.points[[col]], main=paste("Histogram of sampled points", col))))
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) plot(density(envWithPcSf[[col]]), main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) plot(density(virtual.precence.points.pc[[col]]), main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) plot(density(real.sampled.points[[col]]), main=paste("Histogram of sampled points", col))))
load_all
load_all()
matrix(proposalFunction(), 100)
# set sampling parameters
covariance.proposal.function <-0.01
proposalFunction <- addHighDimGaussian(cov_mat =covariance.proposal.function * diag(length(dimensions)), dim = length(dimensions))
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
# setup environment to compute in parallel
num_cores <- detectCores() - 1
cl <- makeCluster(num_cores)
max.distance <- 2
clusterExport(cl, c("mapBackOnRealPoints", "envWithPcSf", "dimensions", "max.distance"))
# map back onto real points
real.sampled.points.list <- parallel::parApply(cl, sampled.points, 1, function(point) mapBackOnRealPoints(envWithPcSf, point, dimensions, threshold = max.distance))
cat(sum(is.na(real.sampled.points.list)) ,"points have no real counterpart in the environment space, given a maximal distance of ", max.distance, "!")
real.sampled.points.list.clean <- real.sampled.points.list[!is.na(real.sampled.points.list)]
real.sampled.points <- do.call(rbind, real.sampled.points.list.clean)
#plot
par(mfrow = c(3, 1))
plot_points_with_lines(real.sampled.points, c("PC1", "PC2", "PC3"), title = paste("Covariance is diagonal ", covariance.proposal.function),
limits = list(c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), c(min(envWithPcSf$PC2), max(envWithPcSf$PC2))))
plot(envWithPcSf$PC1, envWithPcSf$PC2, main = paste("Covariance is diagonal ", covariance.proposal.function))
plot(virtual.precence.points.pc$PC1, virtual.precence.points.pc$PC2, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)),
ylim = c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)) )
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) hist(envWithPcSf[[col]], main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) hist(virtual.precence.points.pc[[col]], main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) hist(real.sampled.points[[col]], main=paste("Histogram of sampled points", col))))
par(mfrow = c(3, length(dimensions)))
invisible(lapply(dimensions, function(col) plot(density(envWithPcSf[[col]]), main=paste("Histogram of environment", col))))
invisible(lapply(dimensions, function(col) plot(density(virtual.precence.points.pc[[col]]), main=paste("Histogram of virtual presence", col))))
invisible(lapply(dimensions, function(col) plot(density(real.sampled.points[[col]]), main=paste("Histogram of sampled points", col))))
covariance.proposal.function * diag(length(dimensions))
randomVector <- mvtnorm::rmvnorm(100, sigma = diag(length(dimensions)))
View(randomVector)
hist(randomVector)
hist(randomVector[1])
hist(randomVector$V1)
hist(randomVector["VI+"])
hist(randomVector["V1"])
hist(randomVector[["V1"])
hist(randomVector[["1"])
hist(randomVector[[1])
hist(randomVector[1)
hist(randomVector[1])
randomVector[1]
randomVector[[1]]
randomVector[[3]]
randomVector[[101]]
randomVector[[1,1]]
randomVector[[1,2]]
hist(randomVector[1,])
hist(randomVector[1,])
randomVector[[1,]]
randomVector[1,]
hist(randomVector[,1])
hist(randomVector[,2])
hist(randomVector[,1])
load_all()
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
proposalFunction <- addHighDimGaussian(cov_mat =covariance.proposal.function * diag(length(dimensions)), dim = length(dimensions))
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
currentPoint
typeof(currentPoint)
randomVector
nextPoint <-  <- currentPoint %>% dplyr::mutate(dplyr::across(dplyr::all_of(dim), ~ . + randomVector[match(dplyr::cur_column(), dim)]))
nextPoint <-  currentPoint %>% dplyr::mutate(dplyr::across(dplyr::all_of(dim), ~ . + randomVector[match(dplyr::cur_column(), dim)]))
nextPoint
cow_mat
cov_mat
mean_vec
altnext <- currentPoint
altnext[dim] <- altnext[dim]+randomVector
randomVector <- mvtnorm::rmvnorm(1, mean = mean_vec, sigma = cov_mat)
altnext[dim] <- altnext[dim]+randomVector
currentPoint[dim]
currentPoint[dim] + randomVector
currentPoint[dim] + randomVector
sf::st_drop_geometry(currentPoint[dim] + randomVector)
?st_drop_geometry
st_drop_geometry(currentPoint)
st_drop_geometry(currentPoint[dim()])
st_drop_geometry(currentPoint[dim])
st_drop_geometry(currentPoint[dim]+randomVector)
toAdd <- sf::st_drop_geometry(currentPoint[dim])
currentPoint[dim] <- toAdd + randomVector
nextPoint[dim] <- toAdd + randomVector
currentPoint
nextPoint
nextPoint[dim] <- toAdd + randomVector
addedHighDimGaussian <- function(currentPoint, dim = ""){
randomVector <- mvtnorm::rmvnorm(1, mean = mean_vec, sigma = cov_mat) %>% c(0)
toAdd <- sf::st_drop_geometry(currentPoint[dim])
nextPoint[dim] <- toAdd + randomVector
}
nextPoint[dim] <- toAdd + randomVector
nextPoint[dim] <- toAdd + randomVector
nextPoint
toAdd <- sf::st_drop_geometry(currentPoint[dim])
nextPoint[dim] <- toAdd + randomVector
currentPoint
nextPoint
randomVector
randomVector <- mvtnorm::rmvnorm(1, mean = mean_vec, sigma = cov_mat)
load_all()
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
load_all()
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
load_all()
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
load_all()
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
install
install()
# sample points
sampled.points <- mcmcSampling(dataset = envWithPcSf, dimensions = dimensions, n.sample.points = 1000,
proposalFunction = proposalFunction, densityFunction = densityFunction)
load_all()
library(mathisRhelpers)
gm()
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
?points
load_all()
load_all()
plotDensity2dpro(dataset =  real.sampled.points, species = virtual.precence.points.pc, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), ylim =c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)),
densityFunction = densityFunction, resolution = 100)
par(mfrow = c(1, 1))
plotDensity2dpro(dataset =  real.sampled.points, species = virtual.precence.points.pc, xlim = c(min(envWithPcSf$PC1), max(envWithPcSf$PC1)), ylim =c(min(envWithPcSf$PC2), max(envWithPcSf$PC2)),
densityFunction = densityFunction, resolution = 100)
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
warning()
warnings()
load_all()
source("~/Desktop/semesterarbeit10/USE.MCMC/development_scripts/mcmc_test_script.R", echo=TRUE)
