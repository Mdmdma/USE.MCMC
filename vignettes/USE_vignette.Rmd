---
title: "USE vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{USE vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In this vignette we will go trough the USE package. 

```{r,  eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, results = FALSE}
# Sys.setlocale("LC_ALL", "English")
library(USE)
library(terra)
library(raster)
library(virtualspecies)
library(sf)
library(ggplot2)
```

## Create Virtual Species
First, download bioclimatic variables from WorldClim and crop them to the European extent
```{r, eval=FALSE, message=FALSE}
Worldclim <- geodata::worldclim_global(var='bio', res=10, path=getwd()) 
envData <- terra::crop(Worldclim, terra::ext(-12, 25, 36, 60))
```
```{r, eval=TRUE, echo=FALSE, message=FALSE, results=FALSE}
envData <- USE::Worldclim_tmp
envData<-rast(envData,  type="xyz")
```

For details about the methodology used to create a virtual species, see the  [vignette](http://borisleroy.com/files/virtualspecies-tutorial.html#introduction) of the **virtualspecies** R package
```{r, eval=FALSE, message=FALSE}
#create virtual species
myRandNum <- sample(1:19,size=5, replace = FALSE)
envData <- envData[[myRandNum]]
```
```{r, eval=TRUE, message=FALSE, warning=FALSE, fig.height = 8, fig.width = 8, fig.align='center'}
set.seed(123)
random.sp <- virtualspecies::generateRandomSp(raster::stack(envData), 
                                              convert.to.PA = FALSE, 
                                              species.type = "additive",
                                              realistic.sp = TRUE, 
                                              plot = FALSE)
#reclassify suitability raster using a probability conversion rule
new.pres <- virtualspecies::convertToPA(x=random.sp, 
                      beta=0.55,
                      alpha = -0.05, plot = FALSE)
#Sample true occurrences
presence.points <- virtualspecies::sampleOccurrences(new.pres,
                                     n = 300, # The number of points to sample
                                     type = "presence-absence",
                                     sample.prevalence = 0.6,
                                     detection.probability = 1,
                                     correct.by.suitability = TRUE,
                                     plot = TRUE)  
```

Create a presence only data set.
```{r, eval=TRUE}
myPres <- presence.points$sample.points[which(presence.points$sample.points$Observed==1), c( "x", "y",  "Observed")]
myPres <- st_as_sf(myPres, coords=c("x", "y"), crs=4326)
```

## Find the optimal resolution of the sampling grid
First, made a PCA on the whole raster stack and then use the PC-scores of the first two axes to create a new spatial object. 
```{r, eval=TRUE}
rpc <- rastPCA(envData, stand = TRUE)
dt <- na.omit(as.data.frame(rpc$PCs[[c("PC1", "PC2")]], xy = TRUE))
dt <- sf::st_as_sf(dt, coords = c("PC1", "PC2"))
```

```{r, eval=FALSE, echo=TRUE}
myRes <- USE::optimRes(sdf=dt,
                    grid.res=c(1:10),
                    perc.thr = 20,
                    showOpt = TRUE, 
                    cr=5)
```

![](myOptRes.png)

```{r, eval=TRUE, echo=FALSE, message=FALSE, results="hide"}
myRes <- list()
myRes$Opt_res <- 5
```
```{r, eval=TRUE}
myRes$Opt_res
```
## Uniform sampling of the environmental space
Perform the uniform sampling of the environmental space
```{r, eval=TRUE, message=FALSE}
myObs <- USE::uniformSampling(sdf=dt, 
                              grid.res=myRes$Opt_res,
                              n.tr = 5,
                              sub.ts = TRUE,
                              n.ts = 2,
                              plot_proc = FALSE)
```

Have a look to the sampled observations from the training dataset
```{r, eval=TRUE}
head(myObs$obs.tr)
```

Plot the uniformly sampled PC-scores along with the observed PC-scores in the environmental space.
```{r, eval=TRUE, message=FALSE, warning=FALSE, fig.height = 6, fig.width = 6, fig.align='center'}
env_pca <- c(rpc$PCs$PC1, rpc$PCs$PC2)
env_pca <- na.omit(as.data.frame(env_pca))

ggplot(env_pca, aes(x=PC1))+
  geom_density(aes(color="Environment"), size=1 )+
  geom_density(data=data.frame(st_coordinates(myObs$obs.tr)), 
               aes(x=X,  color="Uniform"), size=1)+
  scale_color_manual(name=NULL, 
                     values=c('Environment'='#1E88E5', 'Uniform'='#D81B60'))+     
  labs(y="Density of PC-scores")+
  xlim(-5,3)+ ylim(0,1)+
  theme_classic()+
  theme(legend.pos="bottom",  
        text = element_text(size=14),  
        legend.text=element_text(size=12))

ggplot(env_pca, aes(x=PC2))+
  geom_density(aes(color="Environment"), size=1 )+
  geom_density(data=data.frame(st_coordinates(myObs$obs.tr)), 
               aes(x=Y,  color="Uniform"), size=1)+
  scale_color_manual(name=NULL, 
                     values=c('Environment'='#1E88E5', 'Uniform'='#D81B60'))+     
  labs(y="Density of PC-scores")+
  xlim(-5,3)+ ylim(0,1)+
  theme_classic()+
  theme(legend.pos="bottom",  
        text = element_text(size=14),  
        legend.text=element_text(size=12))
```

# Inspecting the effect of the kernel density threshold on the environmental space partitioning 
The function \code{paSampling} performs the uniform sampling of the environmental space excluding those environmental conditions most likely associated with the presence of the species. The environmental space is partitioned using kernel density estimation, a statistical technique used to estimate the underlying probability distribution of a set of data points by smoothing them with a kernel function. The kernel density is used to calculate the probability density function of the presence observations within the 2-dimensional environmental space. The PC-scores associated with a probability threshold equal to or greater than 0.75 (i.e., the default threshold value used in the \code{paSampling} function) are likely to bear environmental conditions associated with the presence locations. Thus, the \code{paSampling} function selects these presence locations and generates a convex hull delimiting the portion of the environmental space mostly associated with this set of presence points within the environmental space. This portion of the environmental space, once targeted, will be then excluded from the uniform sampling. 

Using the \code{thresh.inspect} function, we can explore different kernel threshold values and the effects this choice will have on the pseudo-absences sampling. In principle, setting a low kernel threshold would allow excluding accidental presences from unsuitable locations (e.g., ‘sink populations’) from the training dataset, while potentially including observations from these areas as pseudo-absences.  

```{r, eval=TRUE, message=FALSE, warning=FALSE, fig.height = 6, fig.width = 9, fig.align='center'}
USE::thresh.inspect(env.rast=envData,
                    pres=myPres,
                    thres=c(0.1, 0.25, 0.5, 0.75, 0.9),
                    H=NULL
                    )
```


# Uniform sampling of the pseudo-absences
Now that we have seen how to uniformly sample the environmental space and the effect of the threshold selection on the partition of the environmental space, we can uniformly sampling pseudo-absences in the environmental space while accounting for the environmental space occupied by the species presence points. 
```{r, eval=TRUE, message=FALSE}
myGrid.psAbs <- USE::paSampling(env.rast=envData,
                                pres=myPres,
                                thres=0.75,
                                H=NULL,
                                grid.res=as.numeric(myRes$Opt_res),
                                n.tr = 5,
                                prev=0.3,
                                sub.ts=TRUE,
                                n.ts=5,
                                plot_proc=FALSE,
                                verbose=FALSE)
```

```{r, eval=TRUE, message=FALSE, warning=FALSE, fig.height = 6, fig.width = 6, fig.align='center'}
ggplot(env_pca, aes(x=PC1))+
  geom_density(aes(color="Environment"), size=1 )+
  geom_density(data=data.frame(st_coordinates(myGrid.psAbs$obs.tr)), 
               aes(x=X,  color="Uniform"), size=1)+
  geom_density(data=terra::extract(c(rpc$PCs$PC1, rpc$PCs$PC2), myPres, df=TRUE), 
               aes(x=PC1, color="Presence"), size=1 )+
  scale_color_manual(name=NULL, 
                     values=c('Environment'='#1E88E5', 'Uniform'='#D81B60', "Presence"="black"))+     
  labs(y="Density of PC-scores")+
  xlim(-5,3)+ ylim(0,1)+
  theme_classic()+
  theme(legend.pos="bottom",  
        text = element_text(size=14),  
        legend.text=element_text(size=12))

ggplot(env_pca, aes(x=PC2))+
  geom_density(aes(color="Environment"), size=1 )+
  geom_density(data=data.frame(st_coordinates(myGrid.psAbs$obs.tr)), 
               aes(x=Y,  color="Uniform"), size=1)+
  geom_density(data=terra::extract(c(rpc$PCs$PC1, rpc$PCs$PC2), myPres, df=TRUE), 
               aes(x=PC2, color="Presence"), size=1 )+
  scale_color_manual(name=NULL, 
                     values=c('Environment'='#1E88E5', 'Uniform'='#D81B60', "Presence"="black"))+     
  labs(y="Density of PC-scores")+
  xlim(-5,3)+ ylim(0,1)+
  theme_classic()+
  theme(legend.pos="bottom",  
        text = element_text(size=14),  
        legend.text=element_text(size=12))
```

Plot the pseudo-absences in the geographic space
```{r, eval=TRUE, message=FALSE, warning=FALSE, fig.height = 6, fig.width = 6, fig.align='center'}
ggplot()+
  stars::geom_stars(data = stars::st_as_stars(new.pres$pa.raster), alpha = 0.5 )+
  scale_fill_manual(values =viridis::viridis(2),  na.value = "transparent", 
                  labels = c("Absence", "Presence", ""))+
  geom_sf(data=myPres, 
          aes(color= "Presences"), alpha=1, size=2, shape= 19)+
  geom_sf(data=st_as_sf(st_drop_geometry(myGrid.psAbs$obs.tr), 
                        coords = c("x","y"), crs=4326), 
          aes(color="Pseudo-absences"), alpha=0.8, size=2, shape = 19 )+
    scale_colour_manual(name=NULL, 
                      values=c('Presences'='steelblue', 'Pseudo-absences'='#A41616'))+
  labs(x="Longitude",y="Latitude", fill="Virtual species")+
  theme_light()+
  theme(legend.pos="bottom",  
        legend.background=element_blank(),
        legend.box="vertical",
        panel.grid = element_blank(),
        text = element_text(size=14),  
        legend.text=element_text(size=14), 
        aspect.ratio = 1, 
        panel.spacing.y = unit(2, "lines"))
```